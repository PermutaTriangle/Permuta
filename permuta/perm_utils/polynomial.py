from collections import deque
from itertools import islice
from typing import ClassVar, Deque, Dict, FrozenSet, Iterable, Iterator, Tuple

from permuta.patterns.perm import Perm


class PolyPerms:
    """A static container of methods to check if a perm set has a polynomial growth."""

    PERM_TYPE_0: ClassVar[int] = 0  # W++
    PERM_TYPE_1: ClassVar[int] = 1  # W+-
    PERM_TYPE_2: ClassVar[int] = 2  # W-+
    PERM_TYPE_3: ClassVar[int] = 3  # W--
    PERM_TYPE_4: ClassVar[int] = 4  # Winv++
    PERM_TYPE_5: ClassVar[int] = 5  # Winv+-
    PERM_TYPE_6: ClassVar[int] = 6  # Winv-+
    PERM_TYPE_7: ClassVar[int] = 7  # Winv--
    PERM_TYPE_8: ClassVar[int] = 8  # L2
    PERM_TYPE_9: ClassVar[int] = 9  # L2inv
    _CACHE: ClassVar[Dict[Perm, FrozenSet]] = {}

    @staticmethod
    def _types(perm: Perm) -> FrozenSet[int]:
        interset = PolyPerms._CACHE.get(perm)
        if interset is None:
            interset = frozenset(PolyPerms._find_type(perm))
            PolyPerms._CACHE[perm] = interset
        return interset

    @staticmethod
    def _type_0_3(slice1: Deque[int], slice2: Deque[int]) -> Iterator[int]:
        if PolyPerms._is_incr(slice1):
            if PolyPerms._is_incr(slice2):
                yield PolyPerms.PERM_TYPE_0
            if PolyPerms._is_decr(slice2):
                yield PolyPerms.PERM_TYPE_1
        if PolyPerms._is_decr(slice1):
            if PolyPerms._is_incr(slice2):
                yield PolyPerms.PERM_TYPE_2
            if PolyPerms._is_decr(slice2):
                yield PolyPerms.PERM_TYPE_3

    @staticmethod
    def _type_4_7(slice1: Deque[int], slice2: Deque[int]) -> Iterator[int]:
        if PolyPerms._is_incr(slice1):
            if PolyPerms._is_incr(slice2):
                yield PolyPerms.PERM_TYPE_4
            if PolyPerms._is_decr(slice2):
                yield PolyPerms.PERM_TYPE_5
        if PolyPerms._is_decr(slice1):
            if PolyPerms._is_incr(slice2):
                yield PolyPerms.PERM_TYPE_6
            if PolyPerms._is_decr(slice2):
                yield PolyPerms.PERM_TYPE_7

    @staticmethod
    def _find_type(perm: Perm) -> Iterable[int]:
        p_deq1: Deque[int] = deque([])
        p_deq2: Deque[int] = deque(perm)
        fp_deq1: Deque[int] = deque([])
        fp_deq2: Deque[int] = deque(perm.inverse())
        yield from PolyPerms._type_0_3(p_deq1, p_deq2)
        yield from PolyPerms._type_4_7(fp_deq1, fp_deq2)
        for _ in range(len(perm)):
            p_deq1.append(p_deq2.popleft())
            fp_deq1.append(fp_deq2.popleft())
            yield from PolyPerms._type_0_3(p_deq1, p_deq2)
            yield from PolyPerms._type_4_7(fp_deq1, fp_deq2)
        if PolyPerms._of_type_8(perm):
            yield PolyPerms.PERM_TYPE_8
        if PolyPerms._of_type_8(perm.reverse()):
            yield PolyPerms.PERM_TYPE_9

    @staticmethod
    def _is_decr(perm_slice: Deque[int]) -> bool:
        return all(
            prev > curr for prev, curr in zip(perm_slice, islice(perm_slice, 1, None))
        )

    @staticmethod
    def _is_incr(perm_slice: Deque[int]) -> bool:
        return all(
            prev < curr for prev, curr in zip(perm_slice, islice(perm_slice, 1, None))
        )

    @staticmethod
    def _of_type_8(perm_slice: Tuple[int, ...]) -> bool:
        n = len(perm_slice)
        if n < 2:
            return True
        if perm_slice[-1] == n - 1:
            return PolyPerms._of_type_8(perm_slice[0 : n - 1])
        if perm_slice[-1] == n - 2 and perm_slice[-2] == n - 1:
            return PolyPerms._of_type_8(perm_slice[0 : n - 2])
        return False

    @staticmethod
    def is_polynomial(basis: Iterable[Perm]) -> bool:
        """True iff the perm set generated by basis has polynomial growth."""
        return (
            len({pol_type for perm in basis for pol_type in PolyPerms._types(perm)})
            == 10
        )

    @staticmethod
    def is_non_polynomial(basis: Iterable[Perm]) -> bool:
        """False iff the perm set generated by basis has polynomial growth."""
        return not PolyPerms.is_polynomial(basis)
